using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Moq;
using Nexo.Core.Application.Interfaces.AI;
using Nexo.Core.Application.Interfaces.Extensions;
using Nexo.Core.Application.Services.Extensions;
using Nexo.Core.Domain.Entities.AI;
using Nexo.Core.Domain.Models.Extensions;
using Nexo.Core.Domain.Enums.AI;
using System;
using System.Threading.Tasks;
using Xunit;

namespace Nexo.Core.Application.Tests.Services.Extensions
{
    /// <summary>
    /// End-to-end tests for the complete AI extension generation pipeline
    /// </summary>
    public class EndToEndExtensionGenerationTests
    {
        private readonly ServiceCollection _services;
        private readonly ServiceProvider _serviceProvider;

        public EndToEndExtensionGenerationTests()
        {
            _services = new ServiceCollection();
            SetupServices();
            _serviceProvider = _services.BuildServiceProvider();
        }

        private void SetupServices()
        {
            // Add logging
            _services.AddLogging(builder => builder.AddConsole());

            // Mock AI Engine
            var mockAIEngine = new Mock<IAIEngine>();
            SetupMockAIEngine(mockAIEngine);
            _services.AddSingleton(mockAIEngine.Object);

            // Add real services
            _services.AddSingleton<ICSharpSyntaxValidator, CSharpSyntaxValidator>();
            _services.AddSingleton<IExtensionCompiler, ExtensionCompiler>();
            _services.AddSingleton<AIExtensionGenerator>();
        }

        private void SetupMockAIEngine(Mock<IAIEngine> mockAIEngine)
        {
            // Mock successful code generation
            mockAIEngine.Setup(x => x.GenerateCodeAsync(It.IsAny<CodeGenerationRequest>()))
                .ReturnsAsync(new CodeGenerationResult
                {
                    GeneratedCode = GenerateTestPluginCode()
                });

            // Mock engine info
            mockAIEngine.Setup(x => x.EngineInfo)
                .Returns(new AIEngineInfo
                {
                    EngineType = AIEngineType.Ollama,
                    Name = "TestEngine",
                    Version = "1.0.0"
                });

            // Mock other required properties
            mockAIEngine.Setup(x => x.Status).Returns(AIOperationStatus.Completed);
            mockAIEngine.Setup(x => x.IsInitialized).Returns(true);
            mockAIEngine.Setup(x => x.IsHealthy()).Returns(true);
        }

        private string GenerateTestPluginCode()
        {
            return @"
using System;
using System.Threading;
using System.Threading.Tasks;
using Nexo.Core.Domain.Interfaces;

namespace GeneratedPlugin
{
    public class GeneratedPlugin : IPlugin
    {
        public string Name => ""GeneratedPlugin"";
        public string Version => ""1.0.0"";
        public string Description => ""A plugin generated by AI for testing"";
        public string Author => ""Nexo AI"";
        public bool IsEnabled => true;

        public Task InitializeAsync(IServiceProvider services, CancellationToken cancellationToken = default)
        {
            Console.WriteLine(""GeneratedPlugin initialized successfully!"");
            return Task.CompletedTask;
        }

        public Task ShutdownAsync(CancellationToken cancellationToken = default)
        {
            Console.WriteLine(""GeneratedPlugin shutdown successfully!"");
            return Task.CompletedTask;
        }
    }
}";
        }

        [Fact]
        public async Task EndToEnd_GenerateAndCompileExtension_ShouldSucceed()
        {
            // Arrange
            var generator = _serviceProvider.GetRequiredService<AIExtensionGenerator>();
            var request = new ExtensionRequest
            {
                Name = "GeneratedPlugin",
                Description = "A plugin generated by AI for testing",
                Type = Nexo.Core.Domain.Enums.Extensions.ExtensionType.Custom
            };

            // Act - Generate the extension
            var generationResult = await generator.GenerateExtensionAsync(request);

            // Assert - Verify generation succeeded
            Assert.True(generationResult.IsSuccess, $"Generation failed: {string.Join(", ", generationResult.CompilationErrors)}");
            Assert.NotNull(generationResult.GeneratedCode);
            Assert.True(generationResult.GeneratedCode.Length > 0);
            Assert.NotNull(generationResult.CompiledAssembly);
            Assert.True(generationResult.CompiledAssembly.Length > 0);
            Assert.True(generationResult.GenerationTime > TimeSpan.Zero);
            Assert.True(generationResult.CompilationTime > TimeSpan.Zero);

            Console.WriteLine($"Generation completed in {generationResult.GenerationTime.TotalMilliseconds}ms");
            Console.WriteLine($"Compilation completed in {generationResult.CompilationTime.TotalMilliseconds}ms");
            Console.WriteLine($"Total time: {generationResult.TotalTime.TotalMilliseconds}ms");
            Console.WriteLine($"Generated code length: {generationResult.GeneratedCode.Length} characters");
            Console.WriteLine($"Compiled assembly size: {generationResult.CompiledAssembly.Length} bytes");
        }

        [Fact]
        public async Task EndToEnd_GenerateCodeOnly_ShouldSucceed()
        {
            // Arrange
            var generator = _serviceProvider.GetRequiredService<AIExtensionGenerator>();
            var request = new ExtensionRequest
            {
                Name = "CodeOnlyPlugin",
                Description = "A plugin for code generation testing",
                Type = Nexo.Core.Domain.Enums.Extensions.ExtensionType.Custom
            };

            // Act - Generate code only
            var code = await generator.GenerateCodeAsync(request);

            // Assert
            Assert.NotNull(code);
            Assert.True(code.Length > 0);
            Assert.Contains("class", code);
            Assert.Contains("IPlugin", code);
            Assert.Contains("GeneratedPlugin", code);
        }

        [Fact]
        public async Task EndToEnd_ValidateGeneratedCode_ShouldSucceed()
        {
            // Arrange
            var generator = _serviceProvider.GetRequiredService<AIExtensionGenerator>();
            var testCode = GenerateTestPluginCode();

            // Act - Validate the code
            var validationResult = await generator.ValidateCodeAsync(testCode);

            // Assert
            Assert.True(validationResult.IsValid);
            Assert.Empty(validationResult.Errors);
        }

        [Fact]
        public async Task EndToEnd_CompileGeneratedCode_ShouldSucceed()
        {
            // Arrange
            var generator = _serviceProvider.GetRequiredService<AIExtensionGenerator>();
            var testCode = GenerateTestPluginCode();
            var request = new ExtensionRequest
            {
                Name = "CompiledPlugin",
                Description = "A plugin for compilation testing"
            };

            // Act - Compile the code
            var compilationResult = await generator.CompileCodeAsync(testCode, request);

            // Assert
            Assert.True(compilationResult.IsSuccess);
            Assert.NotNull(compilationResult.CompiledAssembly);
            Assert.True(compilationResult.CompiledAssembly.Length > 0);
            Assert.False(compilationResult.HasCompilationErrors);
        }

        [Fact]
        public async Task EndToEnd_WithInvalidCode_ShouldHandleErrors()
        {
            // Arrange
            var generator = _serviceProvider.GetRequiredService<AIExtensionGenerator>();
            var invalidCode = "public class InvalidPlugin { // Missing closing brace";
            var request = new ExtensionRequest
            {
                Name = "InvalidPlugin",
                Description = "A plugin with syntax errors"
            };

            // Act - Try to compile invalid code
            var compilationResult = await generator.CompileCodeAsync(invalidCode, request);

            // Assert
            Assert.False(compilationResult.IsSuccess);
            Assert.True(compilationResult.HasCompilationErrors);
            Assert.NotEmpty(compilationResult.CompilationErrors);
        }

        [Fact]
        public async Task EndToEnd_ExtensionRequestValidation_ShouldWork()
        {
            // Arrange
            var validRequest = new ExtensionRequest
            {
                Name = "ValidPlugin",
                Description = "A valid plugin request",
                Type = Nexo.Core.Domain.Enums.Extensions.ExtensionType.Custom,
                TargetNamespace = "ValidPluginNamespace"
            };

            var invalidRequest = new ExtensionRequest
            {
                Name = "", // Invalid - empty name
                Description = "", // Invalid - empty description
                Type = Nexo.Core.Domain.Enums.Extensions.ExtensionType.Custom
            };

            // Act & Assert - Valid request
            var validValidation = await Task.FromResult(validRequest.Validate());
            Assert.True(validValidation.IsValid);

            // Act & Assert - Invalid request
            var invalidValidation = await Task.FromResult(invalidRequest.Validate());
            Assert.False(invalidValidation.IsValid);
            Assert.NotEmpty(invalidValidation.Errors);
        }

        [Fact]
        public async Task EndToEnd_PerformanceTest_ShouldCompleteWithinReasonableTime()
        {
            // Arrange
            var generator = _serviceProvider.GetRequiredService<AIExtensionGenerator>();
            var request = new ExtensionRequest
            {
                Name = "PerformanceTestPlugin",
                Description = "A plugin for performance testing",
                Type = Nexo.Core.Domain.Enums.Extensions.ExtensionType.Custom
            };

            var startTime = DateTime.UtcNow;

            // Act - Generate and compile
            var result = await generator.GenerateExtensionAsync(request);

            var endTime = DateTime.UtcNow;
            var totalTime = endTime - startTime;

            // Assert
            Assert.True(result.IsSuccess);
            Assert.True(totalTime.TotalSeconds < 30, $"Operation took too long: {totalTime.TotalSeconds} seconds");
            Assert.True(result.TotalTime.TotalSeconds < 30, $"Total time exceeded limit: {result.TotalTime.TotalSeconds} seconds");

            Console.WriteLine($"Performance test completed in {totalTime.TotalMilliseconds}ms");
        }

        private void Dispose()
        {
            _serviceProvider?.Dispose();
        }
    }
}
